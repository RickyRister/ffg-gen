from argparse import ArgumentParser, _SubParsersAction
from xml.etree import ElementTree
from xml.etree.ElementTree import Element
from pathlib import Path
from typing import Generator
import configs
from dialogueline import DialogueLine
import line_parse
from sysline import SysLine
from generation import text_gen, char_gen, header_gen, fill_gen, tfill_gen
from characterinfo import CharacterInfo
import mlt_fix
from vidpy_extension.ext_composition import ExtComposition, compositions_to_mlt


def attach_subparser_to(subparsers: _SubParsersAction, parents) -> None:
    """Adds the command parser for dialogue scene to the subparser"""

    parser: ArgumentParser = subparsers.add_parser(
        'dialogue', help='Generate mlt for a dialogue scene', parents=parents)

    parser.add_argument(
        'components', nargs='+',
        help='''
        Determines which components to generate. Order does matter; layers go from top to bottom.
        Built-in options: text, header, char:[name], chars, fill:[resource], group:[group], groups

        You can configure macros in your config json under "componentMacros".
        Each macro maps to an array of components.
        Macros can be recursive :)
        ''')

    parser.add_argument(
        '--fill-blanks', action='store_const', const=True, default=False, dest='fill_blanks',
        help='Use transparent clips for waits instead of blanks.')
    parser.add_argument(
        '--chapter', '-c', type=str, default=None,
        help='Only generate this chapter')

    parser.set_defaults(func=dialogue_gen)


def dialogue_gen():
    configs.loadConfigJson(configs.ARGS.config)

    common_lines: list[DialogueLine | SysLine] = None
    chapters: dict[str, list[DialogueLine | SysLine]] = None
    with open(configs.ARGS.input) as inputFile:
        common_lines, chapters = line_parse.parseDialogueFile(inputFile)

    if (chapter_name := configs.ARGS.chapter) is not None:
        # cli args; only process this chapter
        if chapter_name not in chapters:
            raise ValueError(f'{chapter_name} is not a valid chapter.')

        print(f'=== Generating for chapter: {chapter_name} ===')
        process_chapter(chapter_name, common_lines + chapters[chapter_name])
    elif len(chapters) == 0:
        # no chapters; just process all lines
        process_chapter(None, common_lines)
    else:
        # otherwise, process each chapter separately,
        for chapter_name, lines in chapters.items():
            print(f'=== Generating for chapter: {chapter_name} ===')
            # make sure to include the common lines the start
            process_chapter(chapter_name, common_lines + lines)


def process_chapter(chapter_name: str | None, lines: list[DialogueLine | SysLine]):
    '''Processes a single chapter
    Assumes that lines already includes the common lines
    '''
    # generate all compositions
    compositions: list[ExtComposition] = list(process_components(configs.ARGS.components, lines))

    # reverse the list so components render in left-to-right order of cli args
    compositions.reverse()

    print("Done generating. Now exporting combined mlt...")

    xml: Element = compositions_to_mlt(compositions)
    fix_and_write_mlt(xml, chapter_name)


def process_components(components: list[str], lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    '''Creates a generator that will process each component.
    The generator yields the Composition for that component
    '''
    for component in components:
        match component:
            case macro if macro in configs.COMPONENT_MACROS:
                yield from process_components(configs.COMPONENT_MACROS.get(macro), lines)
            case 'text': yield from gen_text(lines)
            case 'header': yield from gen_header(lines)
            case 'chars': yield from gen_chars(lines)
            case 'chars:p': yield from gen_sided_chars(lines, True)
            case 'chars:e': yield from gen_sided_chars(lines, False)
            case x if x.startswith('char:'): yield from gen_char(lines, x.removeprefix('char:'))
            case x if x.startswith('fill:'): yield from gen_fill(lines, x.removeprefix('fill:'))
            case x if x.startswith('tfill:'): yield from gen_tfill(lines, x.removeprefix('tfill:'))
            case 'groups': yield from gen_groups(lines)
            case x if x.startswith('group:'): yield from gen_group(lines, x.removeprefix('group:'))
            case _: raise ValueError(f'{component} is not a valid component.')


def fix_and_write_mlt(mlt: Element, file_suffix: str = None):
    '''Fixes and writes the mlt file generated by Composition
    '''
    fixed_xml: Element = mlt_fix.fix_mlt(mlt)

    suffix: str = '_' + file_suffix if file_suffix is not None else ''
    write_mlt(fixed_xml, suffix)


def write_mlt(xml: Element, suffix: str = ''):
    """Writes the xml to a file.
    The suffix is appended to the output name given by the cli args
    """
    path: Path
    if configs.ARGS.output is not None:
        path = Path(configs.ARGS.output)
        path = path.with_suffix('.mlt')
    else:
        path = Path(configs.ARGS.input)
        path = path.with_suffix('.mlt')

    path = path.with_stem(path.stem + suffix)

    with open(path, 'wb') as outfile:
        xml_string = ElementTree.tostring(xml)
        outfile.write(xml_string)
        print(f'Finished writing output to {path}')

#
# ===  gen_functions ===
# These functions all return generators, even the ones that can only possibly return one Composition
# Means that I don't have to check for None when iterating the result
#


def gen_text(lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    print("Generating text component")
    yield text_gen.generate(lines)


def gen_header(lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    print("Generating header overlay component")
    yield header_gen.generate(lines)


def find_all_names(lines: list[DialogueLine | SysLine]) -> list[str]:
    '''Figures out which names appear in the lines.
    Handles wierdness with aliases
    Preserves the order of appearance in the script.
    '''
    # does weird stuff with dict to ensure uniqueness while preserving order
    names: dict[str] = {line.name: None for line in lines if hasattr(line, 'name')}
    names: dict[str] = {configs.follow_alias(name): None for name in names
                        if name in configs.CHARACTERS or name in configs.GLOBAL_ALIASES}
    return list(names)


def gen_chars(lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    print("Generating all character components...")
    for name in find_all_names(lines):
        yield from gen_char(lines, name)


def gen_sided_chars(lines: list[DialogueLine | SysLine], is_player: bool) -> Generator[ExtComposition, None, None]:
    '''Generates all characters on the given side, making sure that the speaker is always on the top layer
    '''
    print(f"Generating all {'player' if is_player else 'enemy'} character components...")
    # filter out all names on the wrong side
    names: list[str] = find_all_names(lines)
    names = [name for name in names if CharacterInfo.of_name(name).isPlayer == is_player]

    yield from char_gen.generate_sided(lines, names)


def gen_char(lines: list[DialogueLine | SysLine], character: str) -> Generator[ExtComposition, None, None]:
    print(f"Generating character component for {character}")
    yield char_gen.generate(lines, character)


def gen_fill(lines: list[DialogueLine | SysLine], resource: str) -> Generator[ExtComposition, None, None]:
    print(f"Generating fill with {resource}")
    yield fill_gen.generate(lines, resource)


def gen_tfill(lines: list[DialogueLine | SysLine], resource: str) -> Generator[ExtComposition, None, None]:
    print(f"Generating tfill with {resource}")
    yield tfill_gen.generate(lines, resource)


def gen_groups(lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    print(f"Generating components for all component groups...")

    components: list[str] = [line.component for line in lines if hasattr(line, 'group')]
    yield from process_components(components, lines)


def gen_group(lines: list[DialogueLine | SysLine], group: str) -> Generator[ExtComposition, None, None]:
    print(f"Generating components for component group '{group}'")

    components: list[str] = [line.component for line in lines
                             if getattr(line, 'group', None) == group]
    if len(components) == 0:
        print(f"No components found for component group '{group}'")

    yield from process_components(components, lines)
