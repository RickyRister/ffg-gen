from argparse import ArgumentParser, _SubParsersAction
from xml.etree import ElementTree
from xml.etree.ElementTree import Element
from pathlib import Path
from typing import Callable, Generator
import configs
import alias
from dialogueline import DialogueLine
import line_parse
from sysline import SysLine
from generation import text_gen, char_gen, header_gen, fill_gen
from characterinfo import CharacterInfo
import mlt_fix
from vidpy_extension.ext_composition import ExtComposition, compositions_to_mlt


def attach_subparser_to(subparsers: _SubParsersAction, parents) -> None:
    """Adds the command parser for dialogue scene to the subparser"""

    parser: ArgumentParser = subparsers.add_parser(
        'dialogue', help='Generate mlt for a dialogue scene', parents=parents)

    parser.add_argument(
        'components', nargs='+',
        help='''
        Determines which components to generate. Order does matter; layers go from top to bottom.
        Built-in options: text, header, char:[name], chars, fill:[resource], group:[group], groups

        You can configure macros in your config json under "componentMacros".
        Each macro maps to an array of components.
        Macros can be recursive :)
        ''')

    parser.add_argument(
        '--fill-blanks', action='store_const', const=True, default=False, dest='fill_blanks',
        help='Use transparent clips for waits instead of blanks. Could be useful if multiple consecutive blanks are causing issues with durationFix')

    parser.set_defaults(func=dialogue_gen)


def dialogue_gen():
    configs.loadConfigJson(configs.ARGS.config)

    common_lines: list[DialogueLine | SysLine] = None
    chapters: dict[str, list[DialogueLine | SysLine]] = None
    with open(configs.ARGS.input) as inputFile:
        common_lines, chapters = line_parse.parseDialogueFile(inputFile)

    if len(chapters) == 0:
        # no chapters; just process all lines
        process_chapter(None, common_lines)
    else:
        # otherwise, process each chapter separately,
        for chapter_name, lines in chapters.items():
            print(f'=== Generating for chapter: {chapter_name} ===')
            # make sure to include the common lines the start
            process_chapter(chapter_name, common_lines + lines)


def process_chapter(chapter_name: str | None, lines: list[DialogueLine | SysLine]):
    '''Processes a single chapter
    Assumes that lines already includes the common lines
    '''
    # generate all compositions
    compositions: list[ExtComposition] = list(process_components(configs.ARGS.components, lines))

    # reverse the list so components render in left-to-right order of cli args
    compositions.reverse()

    print("Done generating. Now exporting combined mlt...")

    xml: Element = compositions_to_mlt(compositions)
    fix_and_write_mlt(xml, chapter_name)


def process_components(components: list[str], lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    '''Creates a generator that will process each component.
    The generator yields the Composition for that component
    '''
    for component in components:
        match component:
            case macro if macro in configs.COMPONENT_MACROS:
                yield from process_components(configs.COMPONENT_MACROS.get(macro), lines)
            case 'text': yield from gen_text(lines)
            case 'header': yield from gen_header(lines)
            case 'chars': yield from gen_chars(lines)
            case x if x.startswith('char:'): yield from gen_char(lines, x.removeprefix('char:'))
            case x if x.startswith('fill:'): yield from gen_fill(lines, x.removeprefix('fill:'))
            case 'groups': yield from gen_groups(lines)
            case x if x.startswith('group:'): yield from gen_group(lines, x.removeprefix('group:'))
            case _: raise ValueError(f'{component} is not a valid component.')


def reset_configs():
    '''Resets any global configs that might have gotten altered during a run
    '''
    CharacterInfo.get_cached.cache_clear()
    alias.reset_all_local()


def fix_and_write_mlt(mlt: Element, file_suffix: str = None):
    '''Fixes and writes the mlt file generated by Composition
    '''
    fixed_xml: Element = mlt_fix.fix_mlt(mlt)

    suffix: str = '_' + file_suffix if file_suffix is not None else ''
    write_mlt(fixed_xml, suffix)


def write_mlt(xml: Element, suffix: str = ''):
    """Writes the xml to a file.
    The suffix is appended to the output name given by the cli args
    """
    path: Path
    if configs.ARGS.output is not None:
        path = Path(configs.ARGS.output)
    else:
        path = Path(configs.ARGS.input)
        path = path.with_suffix('.mlt')

    path = path.with_stem(path.stem + suffix)

    with open(path, 'wb') as outfile:
        xml_string = ElementTree.tostring(xml)
        outfile.write(xml_string)
        print(f'Finished writing output to {path}')

#
# ===  gen_functions ===
# These functions all return generators, even the ones that can only possibly return one Composition
# Means that I don't have to check for None when iterating the result
# The generators return tuples of (Composition, file_suffix)
#


def wrap_generate(gen_function: Callable[[], ExtComposition]) -> Generator[ExtComposition, None, None]:
    '''Wraps the generate() call to do all the cleanup stuff'''
    try:
        yield gen_function()
    finally:
        reset_configs()


def gen_text(lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    print("Generating text component")
    yield from wrap_generate(lambda: text_gen.generate(lines))


def gen_header(lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    print("Generating header overlay component")
    yield from wrap_generate(lambda: header_gen.generate(lines))


def gen_chars(lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    print("Generating all character components...")

    # figure out which names appear in the dialogue
    names: set[str] = {line.name for line in lines if hasattr(line, 'name')}

    names = {alias.follow_alias(name) for name in names
             if name in configs.CHARACTERS or name in configs.GLOBAL_ALIASES}

    # call gen_char with all those characters
    for name in names:
        yield from gen_char(lines, name)


def gen_char(lines: list[DialogueLine | SysLine], character: str) -> Generator[ExtComposition, None, None]:
    print(f"Generating character component for {character}")
    yield from wrap_generate(lambda: char_gen.generate(lines, character))


def gen_fill(lines: list[DialogueLine | SysLine], resource: str) -> Generator[ExtComposition, None, None]:
    print(f"Generating fill with {resource}")
    yield from wrap_generate(lambda: fill_gen.generate(lines, resource))


def gen_groups(lines: list[DialogueLine | SysLine]) -> Generator[ExtComposition, None, None]:
    print(f"Generating components for all component groups...")

    components: list[str] = [line.component for line in lines if hasattr(line, 'group')]
    yield from process_components(components, lines)


def gen_group(lines: list[DialogueLine | SysLine], group: str) -> Generator[ExtComposition, None, None]:
    print(f"Generating components for component group '{group}'")

    components: list[str] = [line.component for line in lines
                             if getattr(line, 'group', None) == group]
    if len(components) == 0:
        print(f"No components found for component group '{group}'")

    yield from process_components(components, lines)
