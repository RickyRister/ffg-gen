import re
from pathlib import Path
from xml.etree import ElementTree
from xml.etree.ElementTree import Element
from vidpy_extension.ext_composition import ExtComposition, compositions_to_mlt
import cli_args


def createPropertyElement(property: str, value: str) -> Element:
    """Creates xml Element for <property name="{property}">{value}</property>
    """
    element = Element('property', {'name': property})
    element.text = value
    return element


def fix_and_write_mlt(compositions: list[ExtComposition], file_suffix: str = None):
    '''One-stop shop that takes care of both fixing and exporting the mlt

    Args:
        compositions: a list of ExtCompositions to export to an mlt
        file_suffix: if you want the filename stem to have a suffix
    '''
    # generate initial mlt and fix it
    xml: Element = compositions_to_mlt(compositions)
    fixed_xml: Element = fix_mlt(xml)

    # figure out the output path
    path: Path
    if cli_args.ARGS.output is not None:
        path = Path(cli_args.ARGS.output)
        path = path.with_suffix('.mlt')
    else:
        path = Path(cli_args.ARGS.input)
        path = path.with_suffix('.mlt')

    suffix: str = '' if file_suffix is None else '_' + file_suffix
    path = path.with_stem(path.stem + suffix)

    # write the xml
    with open(path, 'wb') as outfile:
        xml_string = ElementTree.tostring(fixed_xml)
        outfile.write(xml_string)
        print(f'Finished writing output to {path}')


def fix_mlt(xml: Element) -> Element:
    """Edits the xml generated by vidpy to make it work in shotcut
    """

    xml = make_mlt_editable(xml)
    xml = fix_filters(xml)

    xml = fix_affine_out(xml)

    return xml


def make_mlt_editable(xml: Element) -> Element:
    tractor_element: Element = xml.find('.//tractor')
    tractor_element.append(createPropertyElement('shotcut', '1'))

    return xml


def fix_filters(xml: Element) -> Element:
    """Add required shotcut-exclusive tags to filters
    """

    for filter_element in xml.findall('.//filter'):
        mlt_service: Element = filter_element.find("./property[@name='mlt_service']").text
        match(mlt_service):
            case 'dynamictext':
                filter_element.append(createPropertyElement('shotcut:filter', 'dynamicText'))
                filter_element.append(createPropertyElement('shotcut:usePointSize', '1'))
                filter_element.append(createPropertyElement(
                    'shotcut:pointSize', filter_element.find("./property[@name='size']").text))
            case 'qtext':
                filter_element.append(createPropertyElement('shotcut:filter', 'richText'))
            case 'mask_start':
                filter_element.append(createPropertyElement('shotcut:filter', 'maskFromFile'))
            case 'affine':
                filter_element.append(createPropertyElement('shotcut:filter', 'affineSizePosition'))
            case 'brightness':
                handle_possible_fades(filter_element)
            case 'frei0r.bigsh0t_eq_to_stereo':
                filter_element.append(createPropertyElement(
                    'shotcut:filter', 'bigsh0t_eq_to_stereo'))

    return xml


def handle_possible_fades(brightness_filter: Element):
    """Possibly adds the appropriate fade in/out shotcut filter tag to the known brightness filter.
    Since we use pure opacity keyframes for fade outs, we only add fade-ins.
    """

    alpha = brightness_filter.find("./property[@name='alpha']")
    if alpha is not None:
        pattern = re.compile(r'[0:\.]+=(?P<initial>\d);(?P<end>.+)=\d')
        matches: re.Match = pattern.match(alpha.text)

        # skip if no match
        if not matches:
            return

        match (matches.group('initial')):
            # initial=0 => fade-in; we do add shotcut fade-in
            case '0':
                brightness_filter.append(createPropertyElement(
                    'shotcut:filter', 'fadeInBrightness'))
                brightness_filter.append(createPropertyElement(
                    'shotcut:animIn', matches.group('end')))
            # initial=1 => fade out; we add shotcut opacity filter tags
            case '1':
                brightness_filter.append(createPropertyElement(
                    'shotcut:filter', 'brightnessOpacity'))
                brightness_filter.append(createPropertyElement('opacity', alpha.text))


def fix_affine_out(xml: Element) -> Element:
    """Copies the out timestamp of the parent producer to any affine filters
    """

    # find all parent nodes of filter nodes
    for producer in xml.findall(".//filter/.."):
        out: str = producer.get('out')

        # loop through all filters nodes of the parent node
        for filter_element in producer.findall('./filter'):

            # replace 'out' if it's an affine filter
            if filter_element.find("./property[@name='mlt_service']").text == 'affine':
                filter_element.set('out', out)

    return xml
