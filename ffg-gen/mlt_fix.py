from xml.etree.ElementTree import Element
import re
import ast
import math
import configs


def createPropertyElement(property: str, value: str) -> Element:
    """Creates xml Element for <property name="{property}">{value}</property>
    """
    element = Element('property', {'name': property})
    element.text = value
    return element


def fix_mlt(xml: Element) -> Element:
    """Edits the xml generated by vidpy to make it work in shotcut
    """

    xml = make_mlt_editable(xml)
    xml = fix_filters(xml)

    # we do not need to do durationFix if we're in frame mode
    if configs.DURATIONS.unit == 'seconds' and not configs.ARGS.no_duration_fix:
        xml = fix_out_timestamps(xml)
    
    xml = fix_affine_out(xml)

    return xml


def make_mlt_editable(xml: Element) -> Element:
    tractor_element: Element = xml.find('.//tractor')
    tractor_element.append(createPropertyElement('shotcut', '1'))

    return xml


def fix_filters(xml: Element) -> Element:
    """Add required shotcut-exclusive tags to filters
    """

    for filter_element in xml.findall('.//filter'):
        mlt_service: Element = filter_element.find("./property[@name='mlt_service']").text
        match(mlt_service):
            case 'dynamictext':
                filter_element.append(createPropertyElement('shotcut:filter', 'dynamicText'))
                filter_element.append(createPropertyElement('shotcut:usePointSize', '1'))
                filter_element.append(createPropertyElement(
                    'shotcut:pointSize', filter_element.find("./property[@name='size']").text))
            case 'qtext':
                filter_element.append(createPropertyElement('shotcut:filter', 'richText'))
            case 'mask_start':
                filter_element.append(createPropertyElement('shotcut:filter', 'maskFromFile'))
            case 'affine':
                filter_element.append(createPropertyElement('shotcut:filter', 'affineSizePosition'))
            case 'brightness':
                handle_possible_fades(filter_element)

    return xml


def handle_possible_fades(brightness_filter: Element):
    """Possibly adds the appropriate fade in/out shotcut filter tag to the known brightness filter.
    Since we use pure opacity keyframes for fade outs, we only add fade-ins.
    """

    alpha = brightness_filter.find("./property[@name='alpha']")
    if alpha is not None:
        pattern = re.compile(r'00:00:00\.000=(?P<initial>\d);(?P<end>.+)=\d')
        matches: re.Match = pattern.match(alpha.text)

        match (matches.group('initial')):
            # initial=0 => fade-in; we do add shotcut fade-in
            case '0':
                brightness_filter.append(createPropertyElement(
                    'shotcut:filter', 'fadeInBrightness'))
                brightness_filter.append(createPropertyElement(
                    'shotcut:animIn', matches.group('end')))
            # initial=1 => fade out; we add shotcut opacity filter tags
            case '1':
                brightness_filter.append(createPropertyElement(
                    'shotcut:filter', 'brightnessOpacity'))
                brightness_filter.append(createPropertyElement('opacity', alpha.text))


def fix_out_timestamps(xml: Element) -> Element:
    """Replace the out timestamps on each producer with the equivalent timestamp, if known.
    """

    # load fixes from config
    fixes: dict[int, str] = {durationFix.expectedFrames: durationFix.fix
                             for durationFix in configs.DURATION_FIX.fixes}

    errorMessages: set[str] = set()

    # loop over all elements that have an 'out' attribute
    for producer in xml.findall('.//*[@out]'):
        outFrame: str = producer.get('out')

        # we only fix frame timestamps
        if not outFrame.isdigit():
            continue

        outFrame: int = int(outFrame)

        # try to get the durationFix
        fix = fixes.get(outFrame)

        if fix is not None:
            # if we have a fix, then use that
            producer.set('out', str(fix))
        else:
            # otherwise, try to calculate a frame fix using the multiplier, if present
            fallbackMultipler: float = configs.DURATION_FIX.fallbackMultiplier
            if fallbackMultipler is None:
                errorMessages.add(f"No duration fix found for frame count {outFrame}")
            else:
                calculated_fix = math.floor(outFrame * fallbackMultipler)
                producer.set('out', str(calculated_fix))
                errorMessages.add(f"No duration fix found for frame count {outFrame}; using fallback multiplier {fallbackMultipler}x")

    # error messages should be deduplicated due to being put in a set
    for msg in errorMessages:
        print(msg)

    return xml


def fix_affine_out(xml: Element) -> Element:
    """Copies the out timestamp of the parent producer to any affine filters
    """

    # find all parent nodes of filter nodes
    for producer in xml.findall(".//filter/.."):
        out: str = producer.get('out')

        # loop through all filters nodes of the parent node
        for filter_element in producer.findall('./filter'):

            # replace 'out' if it's an affine filter
            if filter_element.find("./property[@name='mlt_service']").text == 'affine':
                filter_element.set('out', out)

    return xml
